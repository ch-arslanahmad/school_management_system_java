# database
Testing Database SQL-Lite with java to build school management system project



<h2 align= center>Disable auto commit in JAVA<h2>

##### What is Auto commit?
It is set to true by default, which allows it to after executing the query, change the database without any validation, which in case may cause error and leave the database connection loose, which can cause database locks in SQLite or other problems like incorrect/incomplete/corrupted data inserted.
It is generally recommended that you set the autocommit to false, that makes the execution temporary.
- if during validation or error handling, an error occurs, you can simply rollback to the previous state.
- If no problems occur, the autocommit will change it to true and hence data will be successfully passed & made permanent in the database without any problems.
Hence it is recommended to:

```
conn.setAutoCommit(false);
try {
} catch(Exception e) {
// if something goes wrong you can simply do
conn.rollback();
}
conn.setAutoCommit(true);
```

**For testing**
```
CREATE TABLE Class (
  ClassID INTEGER PRIMARY KEY AUTOINCREMENT,
  ClassName TEXT
);

CREATE TABLE Subjects (
  SubjectID INTEGER PRIMARY KEY AUTOINCREMENT,
  SubjectName TEXT,
  ClassID TEXT,
FOREIGN KEY (ClassID) REFERENCES Class(ClassID)

CREATE TABLE Student (
  StudentID INTEGER PRIMARY KEY AUTOINCREMENT,
  StudentName TEXT,
  ClassID INTEGER,
  FOREIGN KEY (ClassID) REFERENCES Class(ClassID)
);
```
__

Inserting Columns in Tables
```
CREATE TABLE Students(
StudentID INT PRIMARY KEY,
FirstName VARCHAR(50)
LastName VARCHAR(50)
FirstName VARCHAR(50)

)

INSERT INTO students(StudentID, FirstName, LastName)
VALUES(7000, “Arslan”, “Ahmad”);

// to see and view data: asterisk(*) for all
SELECT* FROM Students;
// update data
WHERE “FirstName” = ‘Rizwan’;
Database Management
DBmaker.java
Creates database
DBManager.java
Manages Database in adding, removing,
DAO Folder
So that you can manage each table/class modularly (module by module)
ClassDAO.java
…

Current SQL used in SQLite
CREATE TABLE "Class" (
    "ClassID"    INTEGER,
    "ClassName"    TEXT,
    PRIMARY KEY("ClassID" AUTOINCREMENT)
);
CREATE TABLE "Student" (
    "StudentID"    INTEGER,
    "StudentName"    TEXT,
    "ClassID"    INTEGER,
    FOREIGN KEY("ClassID") REFERENCES "Class"("ClassID") ON DELETE CASCADE,
    PRIMARY KEY("StudentID" AUTOINCREMENT)
);
CREATE TABLE "Subjects" (
    "SubjectID"    INTEGER,
    "SubjectName"    TEXT,
    "ClassID"    INTEGER,
    FOREIGN KEY("ClassID") REFERENCES "Class"("ClassID") ON DELETE CASCADE,
    PRIMARY KEY("SubjectID" AUTOINCREMENT)
);
CREATE TABLE "Teacher" (
    "TeacherID"    INTEGER,
    "TeacherName"    TEXT,
    "SubjectID"    INTEGER,
    FOREIGN KEY("SubjectID") REFERENCES "Subjects"("SubjectID") ON DELETE CASCADE,
    PRIMARY KEY("TeacherID" AUTOINCREMENT)
);
CREATE TABLE "Grade" (
    "GradeID"      INTEGER PRIMARY KEY AUTOINCREMENT,
    "StudentID"    INTEGER,
    "SubjectID"    INTEGER,
    "ObtainedMarks" INTEGER,
    FOREIGN KEY("StudentID") REFERENCES "Student"("StudentID") ON DELETE CASCADE,
    FOREIGN KEY("SubjectID") REFERENCES "Subjects"("SubjectID") ON DELETE CASCADE
);
```

Inserting Dummy Values (Testing)
```
INSERT INTO Class (ClassID, ClassName) VALUES (1,'Class 1');
INSERT INTO Class (ClassID, ClassName) VALUES (2,'Class 2');
INSERT INTO Class (ClassID, ClassName) VALUES (3,'Class 3');
INSERT INTO Student (StudentID, StudentName, ClassID) VALUES (1,'Sara Ahmed',1);
INSERT INTO Student (StudentID, StudentName, ClassID) VALUES (2,'Ali Khan',2);
INSERT INTO Student (StudentID, StudentName, ClassID) VALUES (3,'Hina Malik',1);
INSERT INTO Student (StudentID, StudentName, ClassID) VALUES (4,'Ahmed Raza',2);
INSERT INTO Student (StudentID, StudentName, ClassID) VALUES (5,'Fatima Noor',3);
INSERT INTO Student (StudentID, StudentName, ClassID) VALUES (6,'Bilal Hussain',3);
INSERT INTO Subjects (SubjectID, SubjectName, ClassID) VALUES (1,'Mathematics',1);
INSERT INTO Subjects (SubjectID, SubjectName, ClassID) VALUES (2,'Science',1);
INSERT INTO Subjects (SubjectID, SubjectName, ClassID) VALUES (3,'English',2);
INSERT INTO Subjects (SubjectID, SubjectName, ClassID) VALUES (4,'History',2);
INSERT INTO Subjects (SubjectID, SubjectName, ClassID) VALUES (5,'Physics',3);
INSERT INTO Subjects (SubjectID, SubjectName, ClassID) VALUES (6,'Chemistry',3);
INSERT INTO Teacher (TeacherID, TeacherName, SubjectID) VALUES (1,'Mr. Aslam',1);
INSERT INTO Teacher (TeacherID, TeacherName, SubjectID) VALUES (2,'Ms. Farah',2);
INSERT INTO Teacher (TeacherID, TeacherName, SubjectID) VALUES (3,'Mr. Kamran',3);
INSERT INTO Teacher (TeacherID, TeacherName, SubjectID) VALUES (4,'Mrs. Sana',4);
INSERT INTO Teacher (TeacherID, TeacherName, SubjectID) VALUES (5,'Dr. Imran',5);
INSERT INTO Teacher (TeacherID, TeacherName, SubjectID) VALUES (6,'Prof. Nadia',6);
Automatically Generated by SQLite
CREATE TABLE sqlite_sequence(name,seq);
INSERT INTO sqlite_sequence (name,seq) VALUES ('Class',3);
INSERT INTO sqlite_sequence (name,seq) VALUES ('Student',6);
INSERT INTO sqlite_sequence (name,seq) VALUES ('Subjects',6);
INSERT INTO sqlite_sequence (name,seq) VALUES ('Teacher',6);
```

Updating Values in a Column of a Table
```
UPDATE Subjects SET ObtainedMarks = 95 WHERE SubjectID = 1;
UPDATE Subjects SET ObtainedMarks = 88 WHERE SubjectID = 2;
UPDATE Subjects SET ObtainedMarks = 70 WHERE SubjectID = 3;
UPDATE Subjects SET ObtainedMarks = 40 WHERE SubjectID = 4;
UPDATE Subjects SET ObtainedMarks = 71 WHERE SubjectID = 5;
UPDATE Subjects SET ObtainedMarks = 65 WHERE SubjectID = 6;
```
CREATING VIEW

Another thing that i came across while dealing with DB is
- View
- Triggers
I chose View for my DB at last.
**View:**
View is like a set of instructions stored in the database and you can use it to view the result of the query, hence the name, it is best for read only. View is like a query for a shortcut.
**Triggers:**
Trigger is a stored formula in a column that will automatically change based on a formula.
If you are familiar with excel, it is like in Excel, where formulas are stored in a cell. This is the same with the difference being the scale to a whole column rather than a single cell.

View Query:

First Version:
```
CREATE VIEW GradeView AS
SELECT
    g.SubjectID,                     -- subject reference
    g.ObtainedMarks,
    s.Marks AS TotalMarks
    (g.ObtainedMarks *100.0 / s.Marks) AS Percentage,   -- calculation
    CASE  --Conditional Character assigned
        WHEN (g.ObtainedMarks* 100.0 / s.Marks) >= 90 THEN 'A'
        WHEN (g.ObtainedMarks *100.0 / s.Marks) >= 80 THEN 'B'
        WHEN (g.ObtainedMarks* 100.0 / s.Marks) >= 70 THEN 'C'
        WHEN (g.ObtainedMarks * 100.0 / s.Marks) >= 60 THEN 'D'
        ELSE 'F'
    END AS Grade
FROM Grade g --- naming this table Grade
JOIN Subjects s ON g.SubjectID = s.SubjectID; --Joinining Based on similar subjectID
```
Improved Version: (Finalized and currently used) - Customized to my DB
```
CREATE VIEW GradesView AS
SELECT
    st.StudentID,
    st.StudentName,
    s.SubjectName,
    s.ObtainedMarks,
    s.Marks AS TotalMarks,
    ROUND((s.ObtainedMarks *100.0 / s.Marks), 2) AS Percentage,
    CASE
        WHEN (s.ObtainedMarks* 100.0 / s.Marks) >= 90 THEN 'A'
        WHEN (s.ObtainedMarks *100.0 / s.Marks) >= 80 THEN 'B'
        WHEN (s.ObtainedMarks* 100.0 / s.Marks) >= 70 THEN 'C'
        WHEN (s.ObtainedMarks * 100.0 / s.Marks) >= 60 THEN 'D'
        ELSE 'F'
    END AS Grade
FROM Subjects AS s
JOIN Student AS st
    ON s.ClassID = st.ClassID;

To call this simply type,
SELECT *FROM viewName;
i.e.,
SELECT* FROM GradesView;
```

Update: This shows, all the co
SQL Query to for Report of all Students in a Class
```
SELECT Subjects.SubjectName, Subjects.Marks, Subjects.ObtMarks, Grade.totalMarks, Grade.
``